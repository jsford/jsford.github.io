<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="jrdnfrd.css">
    <title>I wrote a tangram solver.</title>

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="syntax.css">

    <!-- Katex -->
    <link rel="stylesheet" href="katex/katex.min.css">
    <script src="katex/katex.min.js"></script>
    <script src="katex/contrib/auto-render.min.js"></script>

  </head>
  <body>
    <!-- Navigation Bar -->
    <div class="nav" style="background: #2B313C; padding: 0px; padding-bottom: 10px; margin: 0px; height: 50px; position: fixed; top: 0; width: 100%; z-index: 1000;">
      <div class="nav-content" style="display: flex; justify-content: space-between; align-items: center; padding-top: 10px; margin: 0px auto;">
        <a href="index.html"
          style="flex: 20 1 auto; text-align: left;">
          <span class="nav-name" style="font: 1.8em CrimsonPro, Georgia, serif; font-weight: light;">jordan ford.</span>
        </a>
      </div>
    </div>

    <div class="post-content" style="padding-top: 80px; padding-bottom: 70px;">
      <div class="breadcrumb" style="text-align: left; padding-top: 0px; padding-bottom: 20px;">
        <a href="index.html"> home </a><span>&rarr; <a href="#">I wrote a tangram solver.</a></span>
      </div>

      <div class="title">I wrote a tangram solver.</div>
      <div style="padding-top: 10px;"></div>
      <div class="subtitle">It's harder than you think.</div>
      <div style="padding-top: 10px;"/>

      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><img class="post-img" src=tangrams/tangram-pieces.svg alt="" style="width:75%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><img class="post-img" src=tangrams/tangram-puzzle-square.svg alt="" style="width:75%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam. Fermentum dui faucibus in ornare. Suscipit adipiscing bibendum est ultricies integer quis. Amet est placerat in egestas erat imperdiet sed euismod nisi. Id faucibus nisl tincidunt eget nullam non nisi est sit. Nisl vel pretium lectus quam. Nullam eget felis eget nunc lobortis mattis. Sed viverra tellus in hac habitasse platea dictumst vestibulum. Egestas purus viverra accumsan in nisl nisi scelerisque. Pharetra magna ac placerat vestibulum lectus mauris ultrices eros in.</p><p><img class="post-img" src=tangrams/puzzles.svg alt="" style="width:100%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam. Fermentum dui faucibus in ornare. Suscipit adipiscing bibendum est ultricies integer quis. Amet est placerat in egestas erat imperdiet sed euismod nisi. Id faucibus nisl tincidunt eget nullam non nisi est sit. Nisl vel pretium lectus quam. Nullam eget felis eget nunc lobortis mattis. Sed viverra tellus in hac habitasse platea dictumst vestibulum. Egestas purus viverra accumsan in nisl nisi scelerisque. Pharetra magna ac placerat vestibulum lectus mauris ultrices eros in.</p><h1><p> The Search for Solutions</p></h1><p>1. Show a two piece puzzle.
2. Draw the search tree.
3. Explain recursive DFS idea.</p><p><img class="post-img" src=tangrams/example-0.svg alt="" style="width:100%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><img class="post-img" src=tangrams/example-1.svg alt="" style="width:100%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><img class="post-img" src=tangrams/example-2.svg alt="" style="width:100%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><img class="post-img" src=tangrams/example-3.svg alt="" style="width:100%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><img class="post-img" src=tangrams/example-4.svg alt="" style="width:100%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><img class="post-img" src=tangrams/example-5.svg alt="" style="width:100%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><img class="post-img" src=tangrams/example-6.svg alt="" style="width:100%; height:auto;"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><h1><p> Floating-Point Precision Problems</p></h1><p>Floating point precision is the #1 reason tangram solving is hard.
Under the hood, computers represent non-integer numbers like 1.2 or 5.123 using a representation standardized under the name IEEE-754. IEEE-754 floats are great at representing small numbers like 6.626e-34 or huge numbers like 6.022e+23, but they can't represent <em>every</em> number <em>exactly</em>.</p><p>For example, if we try printing the IEEE-754 double precision representation of 1/3, we get 0.3333333333333333148296162...
This is a serious problem if you want to answer exact geometric questions like "is this point <em>exactly</em> on that line?".</p><p><img class="post-img" src=tangrams/floating-point-problem.svg alt="" style="width:80%; height:auto;"></p><p>From our macro perspective, it's easy to say "of course it's on the line!", but your computer will zoom in to the 20th decimal place and say <span class="highlight" style="display: inline-block; padding-left: .3em; padding-right: .3em;"><span class="s">&quot;nope&quot;</span><span class="w"></span>
</span>.</p><p>The standard way to resolve these issues is to change the question. Instead of asking the computer "Is this point <em>exactly</em> on that line?", you ask: "Is this point <em>extremely close</em> to that line?" Sometimes, you might have trouble defining what you mean by <em>extremely close</em>, but usually this hack works just fine.</p><p>With tangrams though, we <em>really do</em> need exact answers to questions like
"Is this point inside that polygon? Or just on its edge?"</p><p>We can try asking approximate questions instead like
"Is this point within 1e-16 units of that line?". Things will even appear to work. But once you add few pieces to your puzzle, those errors in the nth decimal place start to add up.</p><p>Eventually, something will exceed your 1e-16 threshold when it shouldn't. Or by coincidence, something else will come in below your threshold when <em>it</em> shouldn't.</p><p>My first attempt at tangram solving ran into these problems immediately, and no amount of fiddling with tolerances could fix these nasty bugs.</p><h1><p> Squintegers</p></h1><p>Squintegers ( square-root-integers ) are a new number system I invented to solve tangrams using exact math.
I noticed that all edge lengths and coordinates in a tangram puzzle can be represented as (a + bs), where a and b are integer values and s is the square root of two.</p><section class="code"><div class="highlight"><pre><span></span><span class="c1">// Squints are numbers of the form (a+bs), where</span>
<span class="c1">// a and b are integers and s is the square root of two.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Squint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</section><p><strong>Equality</strong> of Squintegers is much simpler than equality between floats. To compare two squintegers, it's sufficient to compare their a and b components. Two Squints are identical if and only if their a and b components are equal.</p>$$ (a+bs) \stackrel{?}{=} (c+ds) \iff (a \stackrel{?}{=} c) \land (b \stackrel{?}{=} d) $$<p><strong>Addition and Subtraction</strong> of Squintegers is also straightforward. The components of the result are equal to the sum or difference of the components of the original values.</p>$$
(a+bs) + (c+ds) = (a+c) + (b+d)s \\
(a+bs) - (c+ds) = (a-c) + (b-d)s
$$<p><strong>Multiplication</strong> is interesting! Multiplying two Squintegers is very similar to multiplying complex numbers.
Importantly, the result of multiplying two Squintegers is also a Squinteger.</p>$$
(a+bs)(c+ds) = ac + ads + bcs + bds^2 = (ac+2bd) + (ad+bc)s
$$<p><strong>Division</strong> is a problem. What is the solution to (1+0s)/(2+0s)? The result, 1/2 cannot be represented as a Squinteger!</p>$$
\frac{(a+bs)}{(c+ds)} = \; ???
$$<p>Squinteger coordinates solve the exact comparison problems we ran into with floating point coordinates, but they don't allow us to do all of the math we need to solve interesting geometry problems using them.</p><h1><p> Sqratios</p></h1><p>Sqratios ( <em>squinteger-ratios, pronounced: skray-shee-owz</em> ) are my solution to the division of Squintegers. Instead of representing coordinates as single Squintegers, we'll represent coordinates as fractions <em>composed</em> of Squintegers.</p><section class="code"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Sqratio</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Squint</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Squint</span><span class="w"> </span><span class="n">den</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</section><p>Similar rational datatypes arise frequently in computational geometry when solving similar (but more important) problems to tangrams. The rules for manipulating Sqratios are the same rules you learned in grade school for manipulating fractions.</p><p><strong>Equality</strong></p>$$
\frac{a_{num}}{a_{den}} \stackrel{?}{=} \frac{b_{num}}{b_{den}} \iff a_{num}b_{den} \stackrel{?}{=} a_{den}b_{num}
$$<p><strong>Comparisons</strong></p>$$
\frac{a_{num}}{a_{den}} \stackrel{?}{<} \frac{b_{num}}{b_{den}} \iff a_{num}b_{den} \stackrel{?}{<} a_{den}b_{num}
$$<p><strong>Addition</strong></p>$$
\frac{a_{num}}{a_{den}} + \frac{b_{num}}{b_{den}} = \frac{ a_{num} b_{den} + a_{den} b_{num} }{ a_{den} b_{den} }
$$<p><strong>Subtraction</strong></p>$$
\frac{a_{num}}{a_{den}} - \frac{b_{num}}{b_{den}} = \frac{ a_{num} b_{den} - a_{den} b_{num} }{ a_{den} b_{den} }
$$<p><strong>Multiplication</strong></p>$$
\frac{a_{num}}{a_{den}} \cdot \frac{b_{num}}{b_{den}} = \frac{ a_{num} b_{num} }{ a_{den} b_{den} }
$$<p><strong>Division</strong></p>$$
\frac{a}{b} = a \cdot \frac{1}{b} = \frac{a_{num}}{a_{den}} \cdot \frac{b_{den}}{b_{num}}
$$<p><strong>Simplification</strong></p>$$
\frac{a}{b} = \frac{ \frac{a}{\mathrm{gcd}(a,b)} }{ \frac{b}{\mathrm{gcd}(a,b)} } = \frac{a'}{b'}
$$<p>Simplifying Sqratios is similar to simplifying fractions. Calculate the greatest-common-divisor of the numerator and denominator, and divide it out of the numerator and the denominator. Sqratios are simplified after every addition, subtraction, multiplication, or division to prevent overflowing the underlying Squintegers.</p><p><strong>Sign Normalization</strong></p>$$
\frac{-a}{-b} \rightarrow \frac{ a }{ b } \qquad \frac{a}{-b} \rightarrow \frac{ -a }{ b }
$$<p>Sign normalization is an important implementation detail. For cross-multiplication to work correctly, it is necessary to hold the sign of a Sqratio in the numerator. Sign normalization flips the sign of the numerator and denominator if the denominator is negative. Sqratios are normalized after every addition, subtraction, multiplication, or division to prevent incorrect comparisons.</p><h1><p> Points and Polygons</p></h1><p>Compared to Squintegers and Sqratios, Points and Polygons are mercifully simple.</p><p>Points are pairs of (x, y) coordinates, where x and y are Sqratios.
Often, I find it helpful to think of Points as 2-D vectors, so I can do things like compute dot products or add two points together.</p><section class="code"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Sqratio</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</section><p>Polygons are simply lists of Points with implicit edges between adjacent points.
Algorithms operating on these polygons must take care to remember the implicit edge connecting the last point in the polygon to the first.</p><section class="code"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Poly</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="n">verts</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</section><aside><p>
<strong>Implementation Note:</strong>
Even though I said "Polygons are lists of Points", polygons are stored using std::vectors, not linked-lists for efficient O(1) access to vertices in the middle of a polygon.
</p></aside><p>In order to distinguish between filled polygons (islands) and unfilled polygons (holes), I use counterclockwise winding order to signify a filled polygon. Almost all polygons that arise during tangram solving are represented by counterclockwise polygons.</p><h1><p> Transforming Polygons</p></h1><p>Placing a tangram piece in a puzzle requires rotating, translating, and (sometimes) flipping it.
Translation is straightforward. I simply add the translation vector to each vertex in the piece and return the result.</p><section class="code"><div class="highlight"><pre><span></span><span class="n">Poly</span><span class="w"> </span><span class="nf">translate</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Poly</span><span class="o">&amp;</span><span class="w"> </span><span class="n">poly</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Poly</span><span class="w"> </span><span class="n">newPoly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poly</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">newPoly</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">newPoly</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</section><p>Rotating pieces is slightly harder because sqratios can't represent arbitrary real numbers.
The only valid rotations are increments of 45&deg;.
If we tried to rotate a sqratio-valued coordinate by say, 30&#176;, the result would no longer be representable using sqratios.</p><p>To make things simple, this routine accepts an integer n, representing the number of times you would like to rotate the piece 45&deg; counterclockwise. I look up the sine and cosine of the given angle and use a 2D rotation matrix to rotate each vertex of the piece.</p><section class="code"><div class="highlight"><pre><span></span><span class="n">Poly</span><span class="w"> </span><span class="nf">rotate_ccw_45deg</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Poly</span><span class="o">&amp;</span><span class="w"> </span><span class="n">poly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Sqratio</span><span class="w"> </span><span class="n">cos</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="n">sin</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="n">sin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="n">sin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="n">sin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="n">sin</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="n">sin</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="n">sin</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="n">sin</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cos</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w">  </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w">    </span><span class="n">sin</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sqratio</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Sqratio</span><span class="o">&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">[</span><span class="n">n</span><span class="o">%</span><span class="mi">8</span><span class="p">];</span><span class="w"> </span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Sqratio</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">[</span><span class="n">n</span><span class="o">%</span><span class="mi">8</span><span class="p">];</span><span class="w"> </span>

<span class="w">    </span><span class="n">Poly</span><span class="w"> </span><span class="n">newPoly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poly</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">newPoly</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">Sqratio</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">*</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">Sqratio</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="o">*</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">newPoly</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</section><p>The last transformation we need is the flip. Flipping a piece is the easiest transformation of all&mdash;I simply invert the x coordinate of every vertex in the piece.</p><section class="code"><div class="highlight"><pre><span></span><span class="n">Poly</span><span class="w"> </span><span class="nf">flip</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Poly</span><span class="o">&amp;</span><span class="w"> </span><span class="n">poly</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Poly</span><span class="w"> </span><span class="n">newPoly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poly</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">newPoly</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">newPoly</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</section><p>Of the seven pieces in the standard tangram set, only the parallelogram requires flipping.
The triangles and square are symmetric, so flipping them would only cause the solver to waste time re-exploring symmetric possibilities. In the solver, every piece includes a boolean to indicate whether or not flipping is required.</p><h1><p> Polygon Area</p></h1><p>One way to decide if a piece fits in a puzzle is to compare the puzzle's area before you remove a piece to the puzzle's area after you remove that piece. If the area of the puzzle decreases by exactly the area of the piece, then you know that the piece fit entirely inside the puzzle.</p><p>A simple way to calculate the area of a 2-D polygon (or an N-D polytope) is to divide the polygon into triangles and sum the signed area of each triangle.</p><p><img class="post-img" src=tangrams/area-example-0.svg alt="" style="width:100%; height:auto;"></p><p>First, pick an arbitrary point. I chose the origin to reduce the amount of math required.
Then, create a triangle using each edge of the polygon and the origin.
The result will be a set of triangles, some with counterclockwise winding order (green) and some with clockwise winding order (red).</p><p>By convention, my polygons are stored in counterclockwise order. Therefore the green triangles contribute positive area, and the red triangles contribute negative area. The sum of the signed triangle areas is equal to the area of the counterclockwise polygon.</p><p><img class="post-img" src=tangrams/area-example-1.svg alt="" style="width:100%; height:auto;"></p><p>This implementation uses the 2D determinant formula to calculate (twice) the signed area of each triangle.
These values are summed together, divided by two, and returned.</p><aside><p>
Wikipedia refers to this algorithm as the triangular form of the <a href="https://en.wikipedia.org/wiki/Shoelace_formula#Triangle_form,_determinant_form" alt="shoelace formula">shoelace formula</a>. <img class="post-img" src=tangrams/kermit.png alt="" style="width:100%; height:auto;">
</p></aside><section class="code"><div class="highlight"><pre><span></span><span class="n">Sqratio</span><span class="w"> </span><span class="nf">polygon_area</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Poly</span><span class="o">&amp;</span><span class="w"> </span><span class="n">poly</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Sqratio</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poly</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">           </span><span class="c1">// current vertex</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poly</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">];</span><span class="w">     </span><span class="c1">// next vertex</span>
<span class="w">      </span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">((</span><span class="n">vc</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vn</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">vc</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vn</span><span class="p">.</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Squint</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</section><p>Factoring out the divide-by-two saves us a few operations.
Normally I wouldn't worry about it, but since we are computing polygon areas in the inner loop of the solver, and since division of Sqratios implies expensive simplification and sign fixup, I figured we might as well.</p><h1><p> Subtracting Polygons</p></h1><p>1. Polygon subtraction is surprisingly hard! Literal edge cases.
2. Here's the basic strategy.
3. Unit testing needed!
4. Creating self-intersecting polygons. Yuck!</p><p><img class="post-img" src=tangrams/self-intersection.svg alt="" style="width:50%; height:auto;"></p><h1><p> Resolving Self-Intersections</p></h1><p>1. The fast pointer, slow pointer algorithm.
2. Find first intersection, start walking.
3. Finally! All of the pieces of the solver are working</p><h1><p> Solving Tangrams</p></h1><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><aside><p>
Don't talk to me about cyclomatic complexity! By my count, this routine involves at least six nested loops.
</p></aside><section class="code"><div class="highlight"><pre><span></span><span class="n">PieceVector</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="n">puzzle</span><span class="p">,</span><span class="w"> </span><span class="n">in_pieces</span><span class="p">,</span><span class="w"> </span><span class="n">out_pieces</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Recursive base case: the puzzle is solved!</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">out_pieces</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">puzzle</span><span class="p">.</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">in_pieces</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Sort pieces by area from largest to smallest.</span>
<span class="w">  </span><span class="n">out_pieces</span><span class="p">.</span><span class="n">sort_by_area</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Pick the largest piece to insert next.</span>
<span class="w">  </span><span class="n">next_piece</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Keep track of the remaining pieces.</span>
<span class="w">  </span><span class="n">next_out_pieces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out_pieces</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// For each polygon in the puzzle...</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">Poly</span><span class="o">&amp;</span><span class="w"> </span><span class="n">puzzle_part</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">puzzle</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// For each vertex in the polygon...</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">puzzle_vertex</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">puzzle_part</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// For each flip of the piece...</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">f</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">f</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// For each vertex in the piece we are inserting...</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="n">piece_vert</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">next_piece</span><span class="p">.</span><span class="n">verts</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// For each rotation of the piece...</span>
<span class="w">          </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">r</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Flip, rotate, and translate the next_piece to place it</span>
<span class="w">            </span><span class="c1">// in the puzzle in the next orientation with its piece_vert</span>
<span class="w">            </span><span class="c1">// on top of the chosen puzzle_vert.</span>

<span class="w">            </span><span class="n">Point</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">puzzle_vert</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">piece_vert</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">Piece</span><span class="w"> </span><span class="n">placed_piece</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transform_piece</span><span class="p">(</span><span class="n">next_piece</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">               </span>
<span class="w">            </span><span class="c1">// Remove placed_piece from all puzzle parts.</span>
<span class="w">            </span><span class="n">next_puzzle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remove_piece_from_puzzle</span><span class="p">(</span><span class="n">puzzle</span><span class="p">,</span><span class="w"> </span><span class="n">placed_piece</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="c1">// If removing the piece did not reduce the puzzle area by</span>
<span class="w">            </span><span class="c1">// exactly the area of the piece, it didn&#39;t fit in the puzzle.</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">puzzle</span><span class="p">.</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">next_puzzle</span><span class="p">.</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">placed_piece</span><span class="p">.</span><span class="n">area</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Otherwise, we found a place where next_piece fits.</span>
<span class="w">            </span><span class="c1">// Let&#39;s remove it from the puzzle and recurse.</span>
<span class="w">            </span><span class="n">subpuzzle_solution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solve</span><span class="p">(</span><span class="n">next_puzzle</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">next_in_pieces</span><span class="p">,</span><span class="w"> </span><span class="n">next_out_pieces</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="c1">// If the subpuzzle was unsolvable, forget this</span>
<span class="w">            </span><span class="c1">// piece placement and go on to the next one.</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">subpuzzle_solution</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Otherwise, add placed_piece to</span>
<span class="w">            </span><span class="c1">// the subpuzzle solution and return it!</span>
<span class="w">            </span><span class="n">subpuzzle_solution</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="w"> </span><span class="n">placed_piece</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">subpuzzle_solution</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</section><h1><p> Results</p></h1><p>1. The solver can handle standard tangrams nooo problem.
2. How long does it take to solve?
3. What is the effect of placing small pieces first?
4. How big can we go? Where to from now?
   Can you solve a giant floor mosaic?</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><video autoplay playsinline muted loop title="" style="width: 40%; height: auto;"><source src="tangrams/classic_square.mp4" type="video/mp4"></p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Morbi non arcu risus quis varius quam quisque id diam.</p><p><video autoplay playsinline muted loop title="" style="width: 30%; height: auto;"><source src="tangrams/sitting_fox.mp4" type="video/mp4"></p><h1><p> Optimization</p></h1><p>The solver works, but can we make it faster? Of course we can! I'd love to hook up a profiler and optimize every instruction, but it's Sunday night, and I'm supposed to be writing a dissertation. Instead, let's pick some low-hanging fruit.</p><p>Right now we're using polygon subtraction to decide if a piece fits into the puzzle. Polygon subtraction is fairly involved, and we're doing it in the inner loop of the solver. Let's see if we can cut down the number of polygon subtractions we do.</p><p>Here's my idea: instead of performing a full subtraction to decide if a piece fits in the puzzle, let's check if all of the piece's vertices fit in the puzzle first. Since the point-in-polygon test is a lot simpler than the polygon subtraction, this could be a cheap way to disqualify piece placements that don't fit inside the puzzle.</p><section class="code"><div class="highlight"><pre><span></span><span class="c1">// Check if every vert of the placed piece is inside of the same part of the</span>
<span class="c1">// puzzle. If not, go on to the next piece orientation. This skips a ton</span>
<span class="c1">// of polygon subtractions and leads to something like a 10x speedup!</span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">abort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">puzzle</span><span class="p">.</span><span class="n">polys</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">all_verts_in_this_part</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vtx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">placed_piece</span><span class="p">.</span><span class="n">poly</span><span class="p">.</span><span class="n">verts</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">point_in_polygon</span><span class="p">(</span><span class="n">part</span><span class="p">,</span><span class="w"> </span><span class="n">vtx</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">all_verts_in_this_part</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">all_verts_in_this_part</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">abort</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">abort</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</section><p>This chunk of code tests each vertex of the puzzle against each polygon component of the current puzzle. If all piece vertices fit inside the same puzzle component, we go ahead and perform the subtraction, just like before. If any piece vertex falls outside of the puzzle, we skip this piece placement and move on to the next one.</p><p>After including this change, the solver is nearly eleven times faster! Before, the solver required 12.5 seconds to solve the classic square puzzle. After this change, the solver takes only 1.16 seconds, an easy 10.7x win! I suspect we could extract another 100x performance gain if we really needed to, but I'm happy with that for now.</p><h1><p> Conclusions</p></h1><p>Someday, computers will take over the world, but they won't do it without a lot of hand-holding from engineers like us. With this work, I've advanced the state-of-the-art in computerized tangram solving. I may have hastened our inevitable subjugation by machines, but at least I learned a lot along the way!</p><p>In order to circumvent floating-point precision issues, I invented Squintegers, a stupid way for computers to represent tangram coordinates with exact math. No, I can't think of any other use for Squintegers, but if you can, send me an email at <a href="mailto:jsford94@gmail.com">jsford94@gmail.com</a>. I'd love to talk to you.</p><p>In the end, I'm happy to have rid the world of another useless, time wasting puzzle. Next to Deep Mind and AlphaGo, I'm sure this blog post will be added to the archive of computer game-solving. Yet another point scored for the machines!</p>

      <div class="breadcrumb" style="text-align: left; padding-top: 20px; padding-bottom: 0px;">
        <a href="index.html">&larr; home </a>
      </div>
    </div>

    <hr style="margin-top: 5%; padding-bottom: 0px; clear: both;"/>
    <div style="text-align: center; font-size: 80%; color: #5a5e67; padding-top: 0px; padding-bottom: 5%;">
      Handcrafted by Jordan Ford &mdash; <span style="position: relative; top: 1px;">&copy;</span> 2022
    </div>

    <script>
      renderMathInElement(
          document.body,
          {
              delimiters: [
                  {left: "$$", right: "$$", display: true},
                  {left: "\\[", right: "\\]", display: true},
                  {left: "$", right: "$", display: false},
                  {left: "\\(", right: "\\)", display: false}
              ]
          }
      );
    </script>
  </body>
</html>